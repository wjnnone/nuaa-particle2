<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>粒子手势交互系统 - 南航特别版</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: 'Microsoft YaHei', sans-serif; /* 确保中文显示 */
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
        }
        /* 隐藏原始视频，只用作数据源 */
        #video-source {
            display: none; 
            transform: scaleX(-1); /* 镜像 */
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 24px;
            z-index: 10;
            text-align: center;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">正在加载模型，请稍候...<br><span style="font-size:14px; color:#aaa;">(首次加载可能需要几秒钟)</span></div>
    <video id="video-source" playsinline></video>
    <canvas id="output-canvas"></canvas>

<script>
    // --- 1. 初始化变量 ---
    const videoElement = document.getElementById('video-source');
    const canvasElement = document.getElementById('output-canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const loadingDiv = document.getElementById('loading');

    let particles = [];
    const PARTICLE_COUNT = 1200; // 粒子数量，卡顿可减小
    const PARTICLE_COLOR = 'rgba(0, 255, 255, 0.8)'; // 青色
    const TEXT_SIZE = 180;
    
    // 状态管理
    let currentText = "Hello"; 
    let interactionState = "neutral"; // neutral, attract, repel
    let interactionPos = { x: -1000, y: -1000 };
    
    // 设置画布尺寸
    function resizeCanvas() {
        canvasElement.width = window.innerWidth;
        canvasElement.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // --- 2. 粒子类定义 ---
    class Particle {
        constructor() {
            this.x = Math.random() * canvasElement.width;
            this.y = Math.random() * canvasElement.height;
            this.vx = 0;
            this.vy = 0;
            this.tx = this.x; // 目标位置
            this.ty = this.y;
            this.size = Math.random() * 2 + 1;
            this.friction = 0.9;
            this.ease = 0.05 + Math.random() * 0.05;
        }

        update() {
            // 1. 飞向目标 (文字形状)
            const dx = this.tx - this.x;
            const dy = this.ty - this.y;
            this.vx += dx * this.ease;
            this.vy += dy * this.ease;

            // 2. 交互力 (右手)
            const dx_m = this.x - interactionPos.x;
            const dy_m = this.y - interactionPos.y;
            const dist_m = Math.sqrt(dx_m * dx_m + dy_m * dy_m);
            const forceRadius = 200;

            if (dist_m < forceRadius) {
                if (interactionState === "attract") {
                    // 握拳：黑洞吸入
                    this.vx -= dx_m * 0.05;
                    this.vy -= dy_m * 0.05;
                } else if (interactionState === "repel") {
                    // 张开：斥力扩散
                    const force = (forceRadius - dist_m) / forceRadius;
                    this.vx += dx_m * force * 0.8;
                    this.vy += dy_m * force * 0.8;
                } else {
                    // 普通经过：扰动
                    const force = (forceRadius - dist_m) / forceRadius;
                    this.vx += dx_m * force * 0.1; 
                    this.vy += dy_m * force * 0.1;
                }
            }

            // 物理更新
            this.vx *= this.friction;
            this.vy *= this.friction;
            this.x += this.vx;
            this.y += this.vy;
        }

        draw() {
            canvasCtx.fillStyle = PARTICLE_COLOR;
            canvasCtx.beginPath();
            canvasCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            canvasCtx.fill();
        }
    }

    // 初始化粒子池
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        particles.push(new Particle());
    }

    // --- 3. 文本转粒子坐标核心逻辑 ---
    let cachedPoints = [];
    
    function updateTextTargets(text) {
        // 创建一个离屏 Canvas 用来分析文字像素
        const offCanvas = document.createElement('canvas');
        offCanvas.width = canvasElement.width;
        offCanvas.height = canvasElement.height;
        const ctx = offCanvas.getContext('2d');

        ctx.font = `bold ${TEXT_SIZE}px "Microsoft YaHei", sans-serif`;
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, offCanvas.width / 2, offCanvas.height / 2);

        // 获取像素数据
        const imageData = ctx.getImageData(0, 0, offCanvas.width, offCanvas.height).data;
        const newPoints = [];
        
        // 采样像素 (step越大越稀疏，性能越好)
        const step = 6; 
        for (let y = 0; y < offCanvas.height; y += step) {
            for (let x = 0; x < offCanvas.width; x += step) {
                const index = (y * offCanvas.width + x) * 4;
                if (imageData[index + 3] > 128) { // 如果不是透明的
                    newPoints.push({x: x, y: y});
                }
            }
        }
        
        // 分配目标点
        // 如果文字点比粒子多，随机取；如果少，剩下的粒子随机飞
        cachedPoints = newPoints;
        for (let i = 0; i < particles.length; i++) {
            if (i < cachedPoints.length) {
                particles[i].tx = cachedPoints[i].x;
                particles[i].ty = cachedPoints[i].y;
            } else {
                // 多余的粒子回到随机位置或者藏起来
                particles[i].tx = Math.random() * canvasElement.width;
                particles[i].ty = Math.random() * canvasElement.height;
            }
        }
    }

    // 初始文字
    updateTextTargets("Hello");

    // --- 4. 手势逻辑处理 ---
    function countFingers(landmarks) {
        // 简单的手指计数逻辑 (Tip y < PIP y)
        // 8:食指, 12:中指, 16:无名指, 20:小指
        let count = 0;
        if (landmarks[8].y < landmarks[6].y) count++;
        if (landmarks[12].y < landmarks[10].y) count++;
        if (landmarks[16].y < landmarks[14].y) count++;
        if (landmarks[20].y < landmarks[18].y) count++;
        // 拇指比较特殊，简单处理：看x坐标是否远离手掌中心
        // 暂时只用4指计数，比较稳定
        return count;
    }

    function isFist(landmarks) {
        // 计算指尖到手腕(0)的平均距离
        const wrist = landmarks[0];
        const tips = [8, 12, 16, 20];
        let totalDist = 0;
        tips.forEach(idx => {
            const dx = landmarks[idx].x - wrist.x;
            const dy = landmarks[idx].y - wrist.y;
            totalDist += Math.sqrt(dx*dx + dy*dy);
        });
        const avgDist = totalDist / 4;
        // 距离阈值需要调试，MediaPipe坐标是0-1归一化的
        return avgDist < 0.25; // 握拳
    }

    function onResults(results) {
        loadingDiv.style.display = 'none';

        // 绘制背景（轻微透明实现拖尾效果，或者纯黑）
        canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);

        // 重置交互状态
        interactionState = "neutral";
        interactionPos = { x: -1000, y: -1000 };

        if (results.multiHandLandmarks) {
            for (const landmarks of results.multiHandLandmarks) {
                // 获取手腕坐标来判断是屏幕左边还是右边
                // 注意：landmarks.x 是 0-1
                const cx = landmarks[0].x; // 0 是手腕

                // --- 左手区域 (屏幕左侧 cx < 0.5) -> 命令控制 ---
                // 注意：因为是镜像模式，用户看到的左边实际上是摄像头的右边
                // 但这里我们已经翻转了canvas绘制，逻辑上：
                // 用户的左手 -> 会出现在屏幕左侧 (如果镜像正确)
                // MediaPipe原始数据中，x方向：左边是0，右边是1。
                
                // 我们直接用屏幕位置逻辑：
                // 如果手在屏幕左半边 (x < 0.5) -> 负责文字
                if (cx < 0.5) {
                    const count = countFingers(landmarks);
                    let newText = currentText;
                    
                    // 逻辑优化：食指(1), 食指+中指(2), 食指+中指+无名指(3)
                    // 为防抖动，只有当手指计数稳定变化时才触发(这里简化直接触发)
                    if (count === 1) newText = "Hello";
                    if (count === 2) newText = "南航";
                    if (count >= 3) newText = "I Love You";

                    if (newText !== currentText) {
                        currentText = newText;
                        updateTextTargets(currentText);
                    }
                }

                // --- 右手区域 (屏幕右侧 cx > 0.5) -> 物理交互 ---
                else {
                    // 映射手掌中心坐标到屏幕像素
                    interactionPos.x = landmarks[9].x * canvasElement.width;
                    interactionPos.y = landmarks[9].y * canvasElement.height;

                    if (isFist(landmarks)) {
                        interactionState = "attract"; // 握拳
                    } else {
                        interactionState = "repel"; // 张开
                    }
                }
            }
        }

        // 更新并绘制所有粒子
        particles.forEach(p => {
            p.update();
            p.draw();
        });
    }

    // --- 5. 启动 MediaPipe ---
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });

    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 1280,
        height: 720
    });

    camera.start();

</script>
</body>
</html>
